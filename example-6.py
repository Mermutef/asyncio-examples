import time
import asyncio

start = time.time()


def tic():
    return f"({time.time() - start:.2f} c)"


async def func1():
    print(f"Функция 1 запущена {tic()}")
    await asyncio.sleep(2)
    print(f"Функция 1 завершена {tic()}")


async def func2():
    print(f"Функция 2 запущена {tic()}")
    await asyncio.sleep(3)
    print(f"Функция 2 завершена {tic()}")


async def func3():
    print(f"Функция 3 запущена {tic()}")
    await asyncio.sleep(1)
    print(f"Функция 3 завершена {tic()}")


async def main():
    await asyncio.gather(
        func1(),
        func2(),
        func3(),
    )
    print(f"Функция main завершена {tic()}")


asyncio.run(main())

'''
                    Разница между асинхронным и многопоточным программированием

    Асинхронное программирование позволяет запускать только одну часть программы в определённый момент времени.

    Пусть у нас есть 3 функции: fn1(), fn2(), и fn3(). В асинхронном программировании, 
если fn1() не выполняется активно (например, находится в спящем режиме, ожидает или завершила выполнение своей задачи), 
она не будет блокировать всю программу. Вместо этого программа оптимизирует использование процессора, 
позволяя другим функциям (например, fn2()) выполняться, пока fn1() неактивна. Только когда fn2() 
завершится или приостановится выполнение третьей функции, fn3() она начнёт выполняться.

    Эта концепция асинхронного программирования гарантирует, что одна задача выполняется одновременно с другими задачами, 
которые могут выполняться независимо.
    
    В многопоточном или многопроцессорном режиме все три функции выполняются одновременно, не дожидаясь завершения друг друга.
    
    При асинхронном программировании определенные функции помечаются как асинхронные с помощью async ключевого слова, 
    а asyncio библиотека Python помогает управлять этим асинхронным поведением.
'''